# Copyright (c) 2019 Uber Technologies, Inc.
#
# <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of the License at
# <p>http://www.apache.org/licenses/LICENSE-2.0
#
# <p>Unless required by applicable law or agreed to in writing, software distributed under the
# License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
# express or implied. See the License for the specific language governing permissions and
# limitations under the License.

#TODO: Add an example for each rule 

[[rules]]
name = "Boolean literal cleanup"
query = """
"""
replace_node = ""
replace = ""

[[rules]]
name = "Statement cleanup"
query = """
"""
replace_node = ""
replace = ""


[[rules]]
name = "Simple If-(optional)else True"
query = """
(
    (if_statement
        condition : ((parenthesized_expression ((true) @i)))
        consequence : ((statement) @s))
@ifstmt)
"""
replace_node = "ifstmt"
replace = "@s"
groups = ["If cleanup"]

[[rules]]
name = "Simple If-else False"
query = """
(
    (if_statement
        condition : ((parenthesized_expression ((false) @i)))
        consequence : ((statement) @s)
        alternative : ((_) @el))
@ifstmt)"""
replace_node = "ifstmt"
replace = "@el"
groups = ["If cleanup"]


[[rules]]
name = "Simple if False"
query = """
(
    (if_statement
        condition : ((parenthesized_expression ((false) @i)))
        consequence : ((statement) @s)
        !alternative)
@ifstmt)
"""
replace_node = "ifstmt"
replace = ""
groups = ["If cleanup"]


[[rules]]
name = "not False"

query = """
(
    (unary_expression
        operator: "!"
        operand: (false))
@u)
"""
replace_node = "u"
replace = "true"
groups = ["Boolean expression simplify"]



[[rules]]
name = "not True"
query = """
(
    (unary_expression
        operator: \"!\"
        operand: (true))
@u)
"""
replace_node = "u"
replace = "false"
groups = ["Boolean expression simplify"]



[[rules]]
name = "Remove unnecesary nested block"
query = """
((block
        (
            (_)* @pre
            (block (_)* @nested.statements) @nested.block
            (_)* @post
        )
    )@sb)"""
replace_node = "nested.block"
replace = "@nested.statements"


[[rules]]
name = "And - left operand is True"
query = """
(
    (binary_expression
        left: (true)
        operator:"&&"
         right : (_)* @other )
) @b"""
replace_node = "b"
replace = "@other"
groups = ["Boolean expression simplify"]


[[rules]]
name = "And - right operand is True"
query = """
(
    (binary_expression
        left : (_)* @other
        operator:"&&"
        right: (true)
    )
@b)"""
replace_node = "b"
replace = "@other"
groups = ["Boolean expression simplify"]



[[rules]]
name = "Or - right operand is True"
query = """
(
    (binary_expression
        left : (_)* @other
        operator:"||"
        right: (true)
    )
@b)"""
replace_node = "b"
replace = "true"
groups = ["Boolean expression simplify"]

[[rules]]
name = "Or - left operand is True"
query = """
(
    (binary_expression
        left : (true)
        operator:"||"
        right: (_)* @other
    )
@b)
"""
replace_node = "b"
replace = "true"
groups = ["Boolean expression simplify"]

[[rules]]
name = "And - left operand is False"
query = """
(
    (binary_expression
        left: (false)
        operator : "&&"
        right : (_)* @other
    )
@bool_expr)"""
replace_node = "bool_expr"
replace = "false"
groups = ["Boolean expression simplify"]

[[rules]]
name = "And - right operand is False"

query = """
(
    (binary_expression
        left : (_)* @other
        operator : "&&"
        right: (false)
    )
@bool_expr)
"""
replace_node = "bool_expr"
replace = "false"
groups = ["Boolean expression simplify"]


[[rules]]
name = "Or - left operand is False"
query = """(
(
    binary_expression
        left : (_)* @other
        operator:"||"
        right: (false)
    )
@b)"""
replace_node = "b"
replace = "@other"
groups = ["Boolean expression simplify"]

[[rules]]
name = "Or - right operand is False"
query = """
(
    (binary_expression
        left : (false)
        operator:"||"
        right: (_)* @other
    )
@b)"""
replace_node = "b"
replace = "@other"
groups = ["Boolean expression simplify"]

[[rules]]
name = "Or - Remove unnecessary brackets from left operand"
query = """(
(
    binary_expression
        left: ((parenthesized_expression
                    (expression !left) @e))
        operator: "||"
        right: (_)* @r)
@bo)"""
replace_node = "bo"
replace = "@e || @r"
groups = ["Boolean expression simplify"]

[[rules]]
name = "Or - Remove unnecessary brackets from right operand"
query = """
(binary_expression
        left: (_)* @l
        operator: "||"
        right: ((parenthesized_expression
                    (expression !left) @e))
@bo)"""
replace = "@l || @e"
replace_node = "bo"
groups = ["Boolean expression simplify"]

[[rules]]
name = "And - Remove unnecessary brackets from left operand "
query = """
(
    (binary_expression
        left: ((parenthesized_expression (expression !left) @e))
        operator: "&&"
        right: (_)* @r)
@bo)"""
replace_node = "bo"
replace = "@e && @r"
groups = ["Boolean expression simplify"]

[[rules]]
name = "And - Remove unnecessary brackets from right operand "
query = """(
    (binary_expression
        left: (_)* @l
        operator: "&&"
        right: ((parenthesized_expression
                         (expression !left) @e)))
@bo)"""
replace_node = "bo"
replace = "@l && @e"
groups = ["Boolean expression simplify"]


[[rules]]
name = "Elide all statements after return"
query = """(
        (block  ((statement)* @pre)
         ((return_statement) @r)
         ((statement)+ @post)) @b)"""
replace_node = "post"
replace = ""

[[rules]]
name = "Ternay operator True"
query = """
(
    (ternary_expression condition: (true)
        consequence: (_)* @then
        alternative: (_)* @else)
@tt)"""
replace_node = "tt"
replace = "@then"
groups = ["If cleanup"]

[[rules]]
name = "Ternay operator False"
query = """
(
    (ternary_expression condition: (false)
        consequence: (_)* @then
        alternative: (_)* @else)
@tt)"""
replace_node = "tt"
replace = "@else"
groups = ["If cleanup"]

# [[rules]]
# name = "Parenthesized boolean literal"
# query = """
# (
# (parenthesized_expression 
# 	[(true)
#      (false)
#     ] @l
#     ) @p
# )
# """
# replace = "@l"
# groups = ["Boolean expression simplify"]

[[rules]]
name = "Inline Local Variable Declaration - Delete variable declaration"
query = """
(
((local_variable_declaration 
				declarator: (variable_declarator 
                					name: (_) @n
                					value: [(true) (false)] @v)) @l)
)
"""
replace_node = "l"
replace = ""
groups = []
[rules.constraint]
matcher = "(method_declaration) @md"
predicate = "None"
queries = ["""
(
((assignment_expression
    				left: (_) @o1
                    right: (_) @r) @a)
(#eq? @o1 "@n")
(#not-eq? @r "@v")
)"""]

# TODO: Add a inline field declaration without RHS.
[[rules]]
name = "Inline Field Declaration - Delete field declaration"
query = """
(
((field_declaration 
				declarator: (variable_declarator 
                					name: (_) @n
                					value: [(true) (false)] @v)) @l)
)
"""
replace_node = "l"
replace = ""
groups = []
[rules.constraint]
matcher = "(class_declaration) @cd"
predicate = "None"
queries = ["""(
((assignment_expression
    				left: (_) @o
                    right: (_) @r) @a)
(#eq? @o "@n")
(#not-eq? @r "@v")
)"""]

[[rules]]
name = "Remove assignment"
query = """
(
(expression_statement (assignment_expression
                                left: (_) @l
                    right: (_) @r)) @e
(#eq? @l "@n")
(#eq? @r "@v")
) 
"""
replace_node = "e"
replace = ""
groups = []
holes = ["n", "v"]

# Remove assignment if it is the only assignment in the entire class. 
# This should be done in class and method scope. But while deleting the assignment, 
# we cannot guess if the lhs is a field or a local variable.
[[rules]]
name = "Remove assignment-1"
query = """
(
(expression_statement (assignment_expression
                                left: (_) @l
                    right: [(true) (false)] @v)) @e
) 
"""
replace_node = "e"
replace = ""
groups = []
holes = []
[rules.constraint]
matcher = "(class_declaration) @cd"
predicate = "None"
queries = ["""(
((assignment_expression
    				left: (_) @u1
                    right: (_) @k) @a)
(#eq? @u1 "@l")
(#not-eq? @k "@v")
)"""]

[[rules]]
name = "Replace identifier with value"
query = """
(
(identifier )@i
(#eq? @i "@n")
)
"""
replace_node = "i"
replace = "@v"
groups = []
holes = ["n", "v"]

